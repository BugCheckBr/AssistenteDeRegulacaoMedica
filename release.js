require("dotenv").config();
const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");
const simpleGit = require("simple-git");
const { Octokit } = require("@octokit/rest");

const git = simpleGit();
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const owner = "ShadyBS";
const repo = "AssistenteDeRegulacaoMedica";

// Passo 1: Obter a √∫ltima tag
async function getLastTag() {
  const tags = await git.tags();
  return tags.latest;
}

// Passo 2: Gerar changelog desde a √∫ltima tag
async function getChangelog(fromTag) {
  const log = await git.log({ from: fromTag, to: "HEAD" });
  return log.all.map((entry) => `- ${entry.message}`).join("\n");
}

// Passo 3: Atualizar manifests (remove BOM e atualiza vers√£o)
function updateManifestVersion(newVersion) {
  const files = ["manifest.json", "manifest-edge.json"];
  files.forEach((file) => {
    const manifestPath = path.join(__dirname, file);
    if (!fs.existsSync(manifestPath)) {
      console.warn(`‚ö†Ô∏è Arquivo n√£o encontrado: ${file}`);
      return;
    }
    try {
      let content = fs.readFileSync(manifestPath, "utf8");
      content = content.replace(/^\uFEFF/, "");
      const manifest = JSON.parse(content);
      manifest.version = newVersion;
      fs.writeFileSync(
        manifestPath,
        JSON.stringify(manifest, null, 2) + "\n",
        "utf8"
      );
      console.log(`‚úÖ Atualizado ${file} para vers√£o ${newVersion}`);
    } catch (err) {
      console.error(`‚ùå Erro ao processar ${file}:`, err.message);
    }
  });
}

// Passo 4: Rodar build com Tailwind
function buildTailwind() {
  console.log("üé® Gerando CSS com Tailwind...");
  execSync("npx tailwindcss -i ./src/input.css -o ./dist/output.css --minify", {
    stdio: "inherit",
  });
}

// Passo 5: Gerar zips
function buildZips() {
  console.log("üì¶ Gerando ZIPs...");
  execSync("node build-zips.js", { stdio: "inherit" });
}

// Passo 6: Commit, tag e push no Git
async function createGitTag(newVersion) {
  await git.add(".");
  await git
    .commit(`release: v${newVersion}`)
    .catch(() => console.log("‚ö†Ô∏è Nenhum arquivo modificado para commit."));
  const tags = await git.tags();
  if (tags.all.includes(`v${newVersion}`)) {
    console.log(`‚ö†Ô∏è Tag v${newVersion} j√° existe, pulando cria√ß√£o de tag.`);
  } else {
    await git.addTag(`v${newVersion}`);
    await git.pushTags();
    console.log(`‚úÖ Tag v${newVersion} criada e enviada.`);
  }
  await git.push("origin", "main");
}

// Passo 7: Criar release no GitHub e fazer upload dos ZIPs
async function createRelease(newVersion, changelog) {
  console.log("üöÄ Criando release no GitHub...");
  try {
    const releaseResponse = await octokit.repos.createRelease({
      owner,
      repo,
      tag_name: `v${newVersion}`,
      name: `v${newVersion}`,
      body: changelog,
      draft: false,
      prerelease: false,
    });
    console.log(`‚úÖ Release v${newVersion} criado com sucesso!`);

    // Upload dos assets
    const release_id = releaseResponse.data.id;
    const DIST_ZIPS_DIR = path.join(__dirname, "dist-zips");
    const zipFiles = fs
      .readdirSync(DIST_ZIPS_DIR)
      .filter((f) => f.endsWith(".zip"));

    if (zipFiles.length === 0) {
      console.warn(
        "‚ö†Ô∏è Nenhum arquivo .zip encontrado em dist-zips para fazer upload."
      );
      return;
    }

    console.log("‚¨ÜÔ∏è  Fazendo upload dos ZIPs para a release...");
    for (const file of zipFiles) {
      const filePath = path.join(DIST_ZIPS_DIR, file);
      console.log(`  -> Uploading ${file}...`);
      await octokit.repos.uploadReleaseAsset({
        owner,
        repo,
        release_id,
        name: file,
        data: fs.readFileSync(filePath),
      });
    }
    console.log("‚úÖ Todos os ZIPs foram enviados com sucesso.");
  } catch (err) {
    console.error(
      `‚ùå Falha ao criar release ou fazer upload de assets no GitHub: ${err.message}`
    );
    console.error(
      `‚Üí Verifique se o GITHUB_TOKEN possui permiss√µes de "contents: write" e se est√° configurado corretamente.`
    );
    process.exit(1);
  }
}

// Fluxo principal
async function run() {
  const newVersion = process.argv[2];
  if (!newVersion) {
    console.error(
      "‚ö†Ô∏è Voc√™ precisa passar a nova vers√£o. Ex: node release.js 3.2.12"
    );
    process.exit(1);
  }
  const lastTag = await getLastTag();
  const changelog = await getChangelog(lastTag);
  updateManifestVersion(newVersion);
  buildTailwind();
  buildZips();
  await createGitTag(newVersion);
  await createRelease(newVersion, changelog);
}

run();
