# Prompt para Internacionaliza√ß√£o de Extens√µes de Navegador

## üåê MISS√ÉO: IMPLEMENTA√á√ÉO COMPLETA DE SUPORTE MULTI-IDIOMA

Voc√™ √© um **Senior Browser Extension Internationalization Engineer** especializado em **localiza√ß√£o avan√ßada** para extens√µes **Manifest V3**. Implemente **suporte completo a m√∫ltiplos idiomas**, **adapta√ß√µes culturais** e **gerenciamento de tradu√ß√µes** para criar extens√µes **globalmente acess√≠veis**.

---

## üéØ INSTRU√á√ïES INICIAIS OBRIGAT√ìRIAS

**ANTES DE IMPLEMENTAR I18N:**
1. **SEMPRE leia o arquivo `agents.md`** - Cont√©m especifica√ß√µes do projeto atual
2. **Analise mercados-alvo** - Identifique idiomas e regi√µes priorit√°rias
3. **Audite strings existentes** - Catalogue todo texto da extens√£o
4. **Configure estrutura i18n** - Setup de arquivos e sistema
5. **Implemente detec√ß√£o de idioma** - Auto-detec√ß√£o e sele√ß√£o manual
6. **Adapte layouts** - RTL, comprimento de texto, formata√ß√£o
7. **Configure pipeline de tradu√ß√£o** - Workflow para tradutores

---

## üåç SISTEMA DE INTERNACIONALIZA√á√ÉO ABRANGENTE

### **üó£Ô∏è IDIOMAS E REGI√ïES SUPORTADAS**

#### **Tier 1 - Idiomas Priorit√°rios**
```typescript
interface PrimaryLanguages {
  'en': {
    name: 'English',
    region: 'US',
    direction: 'ltr',
    marketSize: 'large',
    priority: 1
  };
  'es': {
    name: 'Espa√±ol',
    region: 'ES',
    direction: 'ltr',
    marketSize: 'large',
    priority: 1
  };
  'fr': {
    name: 'Fran√ßais',
    region: 'FR',
    direction: 'ltr',
    marketSize: 'large',
    priority: 1
  };
  'de': {
    name: 'Deutsch',
    region: 'DE',
    direction: 'ltr',
    marketSize: 'large',
    priority: 1
  };
  'pt': {
    name: 'Portugu√™s',
    region: 'BR',
    direction: 'ltr',
    marketSize: 'large',
    priority: 1
  };
  'zh': {
    name: '‰∏≠Êñá',
    region: 'CN',
    direction: 'ltr',
    marketSize: 'large',
    priority: 1
  };
  'ja': {
    name: 'Êó•Êú¨Ë™û',
    region: 'JP',
    direction: 'ltr',
    marketSize: 'medium',
    priority: 1
  };
  'ko': {
    name: 'ÌïúÍµ≠Ïñ¥',
    region: 'KR',
    direction: 'ltr',
    marketSize: 'medium',
    priority: 1
  };
}
```

#### **Tier 2 - Idiomas Secund√°rios**
```typescript
interface SecondaryLanguages {
  'ru': { name: '–†—É—Å—Å–∫–∏–π', region: 'RU', direction: 'ltr' };
  'it': { name: 'Italiano', region: 'IT', direction: 'ltr' };
  'nl': { name: 'Nederlands', region: 'NL', direction: 'ltr' };
  'pl': { name: 'Polski', region: 'PL', direction: 'ltr' };
  'tr': { name: 'T√ºrk√ße', region: 'TR', direction: 'ltr' };
  'ar': { name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', region: 'SA', direction: 'rtl' };
  'he': { name: '◊¢◊ë◊®◊ô◊™', region: 'IL', direction: 'rtl' };
  'hi': { name: '‡§π‡§ø‡§®‡•ç‡§¶‡•Ä', region: 'IN', direction: 'ltr' };
  'th': { name: '‡πÑ‡∏ó‡∏¢', region: 'TH', direction: 'ltr' };
  'vi': { name: 'Ti·∫øng Vi·ªát', region: 'VN', direction: 'ltr' };
}
```

### **üìÅ Estrutura de Arquivos i18n**

```
_locales/
‚îú‚îÄ‚îÄ en/
‚îÇ   ‚îú‚îÄ‚îÄ messages.json              # Mensagens principais
‚îÇ   ‚îú‚îÄ‚îÄ ui.json                    # Textos de interface
‚îÇ   ‚îú‚îÄ‚îÄ errors.json                # Mensagens de erro
‚îÇ   ‚îú‚îÄ‚îÄ help.json                  # Textos de ajuda
‚îÇ   ‚îî‚îÄ‚îÄ store.json                 # Descri√ß√µes para store
‚îú‚îÄ‚îÄ es/
‚îÇ   ‚îú‚îÄ‚îÄ messages.json
‚îÇ   ‚îú‚îÄ‚îÄ ui.json
‚îÇ   ‚îú‚îÄ‚îÄ errors.json
‚îÇ   ‚îú‚îÄ‚îÄ help.json
‚îÇ   ‚îî‚îÄ‚îÄ store.json
‚îú‚îÄ‚îÄ fr/
‚îÇ   ‚îî‚îÄ‚îÄ ... (mesma estrutura)
‚îú‚îÄ‚îÄ de/
‚îÇ   ‚îî‚îÄ‚îÄ ... (mesma estrutura)
‚îú‚îÄ‚îÄ pt/
‚îÇ   ‚îî‚îÄ‚îÄ ... (mesma estrutura)
‚îú‚îÄ‚îÄ zh/
‚îÇ   ‚îî‚îÄ‚îÄ ... (mesma estrutura)
‚îú‚îÄ‚îÄ ja/
‚îÇ   ‚îî‚îÄ‚îÄ ... (mesma estrutura)
‚îú‚îÄ‚îÄ ko/
‚îÇ   ‚îî‚îÄ‚îÄ ... (mesma estrutura)
‚îî‚îÄ‚îÄ config/
    ‚îú‚îÄ‚îÄ languages.json             # Configura√ß√£o de idiomas
    ‚îú‚îÄ‚îÄ regions.json               # Configura√ß√£o de regi√µes
    ‚îú‚îÄ‚îÄ formats.json               # Formatos por regi√£o
    ‚îî‚îÄ‚îÄ fallbacks.json             # Idiomas de fallback
```

### **üîß Sistema de Internacionaliza√ß√£o**

#### **Core i18n Manager**
```javascript
// Advanced Internationalization Manager
class InternationalizationManager {
  constructor() {
    this.currentLocale = null;
    this.fallbackLocale = 'en';
    this.messages = new Map();
    this.formatters = new Map();
    this.rtlLanguages = ['ar', 'he', 'fa', 'ur'];
    this.loadedLocales = new Set();
    
    this.initialize();
  }

  async initialize() {
    // Detect user's preferred language
    this.currentLocale = await this.detectUserLanguage();
    
    // Load messages for current locale
    await this.loadLocale(this.currentLocale);
    
    // Load fallback locale if different
    if (this.currentLocale !== this.fallbackLocale) {
      await this.loadLocale(this.fallbackLocale);
    }
    
    // Setup formatters
    this.setupFormatters();
    
    // Apply locale to DOM
    this.applyLocaleToDOM();
    
    console.log(`üåê i18n initialized with locale: ${this.currentLocale}`);
  }

  async detectUserLanguage() {
    // Try to get from storage first
    const stored = await chrome.storage.sync.get('user_language');
    if (stored.user_language) {
      return stored.user_language;
    }

    // Get browser language
    const browserLang = chrome.i18n.getUILanguage();
    const primaryLang = browserLang.split('-')[0];

    // Check if we support this language
    const supportedLanguages = await this.getSupportedLanguages();
    
    if (supportedLanguages.includes(browserLang)) {
      return browserLang;
    } else if (supportedLanguages.includes(primaryLang)) {
      return primaryLang;
    }

    // Fallback to English
    return this.fallbackLocale;
  }

  async getSupportedLanguages() {
    try {
      const response = await fetch(chrome.runtime.getURL('_locales/config/languages.json'));
      const config = await response.json();
      return Object.keys(config.supported);
    } catch (error) {
      console.error('Failed to load language config:', error);
      return ['en'];
    }
  }

  async loadLocale(locale) {
    if (this.loadedLocales.has(locale)) return;

    try {
      // Load all message files for this locale
      const messageFiles = ['messages', 'ui', 'errors', 'help', 'store'];
      const messages = {};

      for (const file of messageFiles) {
        try {
          const response = await fetch(chrome.runtime.getURL(`_locales/${locale}/${file}.json`));
          const fileMessages = await response.json();
          Object.assign(messages, fileMessages);
        } catch (error) {
          console.warn(`Failed to load ${file}.json for ${locale}:`, error);
        }
      }

      this.messages.set(locale, messages);
      this.loadedLocales.add(locale);
      
      console.log(`üìÑ Loaded ${Object.keys(messages).length} messages for ${locale}`);
    } catch (error) {
      console.error(`Failed to load locale ${locale}:`, error);
    }
  }

  getMessage(key, substitutions = [], locale = null) {
    const targetLocale = locale || this.currentLocale;
    
    // Try current locale first
    let messages = this.messages.get(targetLocale);
    let message = messages?.[key];

    // Fallback to default locale
    if (!message && targetLocale !== this.fallbackLocale) {
      messages = this.messages.get(this.fallbackLocale);
      message = messages?.[key];
    }

    // If still no message, return key
    if (!message) {
      console.warn(`Missing translation for key: ${key}`);
      return key;
    }

    // Handle Chrome i18n format
    if (typeof message === 'object' && message.message) {
      message = message.message;
    }

    // Substitute placeholders
    if (substitutions.length > 0) {
      message = this.substitutePlaceholders(message, substitutions);
    }

    return message;
  }

  substitutePlaceholders(message, substitutions) {
    // Handle Chrome i18n placeholders ($1, $2, etc.)
    return message.replace(/\$(\d+)/g, (match, index) => {
      const subIndex = parseInt(index) - 1;
      return substitutions[subIndex] || match;
    });
  }

  // Shorthand method
  t(key, substitutions = []) {
    return this.getMessage(key, substitutions);
  }

  async setLocale(locale) {
    if (locale === this.currentLocale) return;

    // Load new locale if not already loaded
    await this.loadLocale(locale);

    // Update current locale
    this.currentLocale = locale;

    // Save to storage
    await chrome.storage.sync.set({ user_language: locale });

    // Update formatters
    this.setupFormatters();

    // Apply to DOM
    this.applyLocaleToDOM();

    // Notify listeners
    this.notifyLocaleChange(locale);

    console.log(`üåê Locale changed to: ${locale}`);
  }

  setupFormatters() {
    const locale = this.currentLocale;

    // Number formatter
    this.formatters.set('number', new Intl.NumberFormat(locale));

    // Currency formatter
    this.formatters.set('currency', new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: this.getCurrencyForLocale(locale)
    }));

    // Date formatters
    this.formatters.set('date', new Intl.DateTimeFormat(locale));
    this.formatters.set('datetime', new Intl.DateTimeFormat(locale, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    }));
    this.formatters.set('time', new Intl.DateTimeFormat(locale, {
      hour: '2-digit',
      minute: '2-digit'
    }));

    // Relative time formatter
    if (Intl.RelativeTimeFormat) {
      this.formatters.set('relative', new Intl.RelativeTimeFormat(locale));
    }
  }

  getCurrencyForLocale(locale) {
    const currencyMap = {
      'en': 'USD',
      'en-US': 'USD',
      'en-GB': 'GBP',
      'en-CA': 'CAD',
      'en-AU': 'AUD',
      'es': 'EUR',
      'es-ES': 'EUR',
      'es-MX': 'MXN',
      'fr': 'EUR',
      'de': 'EUR',
      'pt': 'EUR',
      'pt-BR': 'BRL',
      'zh': 'CNY',
      'zh-CN': 'CNY',
      'ja': 'JPY',
      'ko': 'KRW'
    };

    return currencyMap[locale] || currencyMap[locale.split('-')[0]] || 'USD';
  }

  formatNumber(number, options = {}) {
    const formatter = this.formatters.get('number');
    return formatter.format(number);
  }

  formatCurrency(amount, currency = null) {
    if (currency) {
      const formatter = new Intl.NumberFormat(this.currentLocale, {
        style: 'currency',
        currency
      });
      return formatter.format(amount);
    }
    
    const formatter = this.formatters.get('currency');
    return formatter.format(amount);
  }

  formatDate(date, style = 'date') {
    const formatter = this.formatters.get(style);
    return formatter.format(date);
  }

  formatRelativeTime(value, unit) {
    const formatter = this.formatters.get('relative');
    return formatter ? formatter.format(value, unit) : `${value} ${unit}`;
  }

  applyLocaleToDOM() {
    if (typeof document === 'undefined') return;

    // Set document language and direction
    document.documentElement.lang = this.currentLocale;
    document.documentElement.dir = this.isRTL() ? 'rtl' : 'ltr';

    // Update all elements with data-i18n attribute
    const elements = document.querySelectorAll('[data-i18n]');
    
    elements.forEach(element => {
      const key = element.getAttribute('data-i18n');
      const message = this.getMessage(key);
      
      if (element.tagName === 'INPUT' && element.type === 'text') {
        element.placeholder = message;
      } else {
        element.textContent = message;
      }
    });

    // Update elements with data-i18n-title attribute
    const titleElements = document.querySelectorAll('[data-i18n-title]');
    titleElements.forEach(element => {
      const key = element.getAttribute('data-i18n-title');
      element.title = this.getMessage(key);
    });

    // Apply RTL/LTR specific styles
    this.applyDirectionalStyles();
  }

  isRTL() {
    return this.rtlLanguages.includes(this.currentLocale.split('-')[0]);
  }

  applyDirectionalStyles() {
    if (typeof document === 'undefined') return;

    const isRTL = this.isRTL();
    
    // Add/remove RTL class
    document.body.classList.toggle('rtl', isRTL);
    document.body.classList.toggle('ltr', !isRTL);

    // Update CSS custom properties for direction-aware styling
    document.documentElement.style.setProperty('--text-direction', isRTL ? 'rtl' : 'ltr');
    document.documentElement.style.setProperty('--start-direction', isRTL ? 'right' : 'left');
    document.documentElement.style.setProperty('--end-direction', isRTL ? 'left' : 'right');
  }

  notifyLocaleChange(locale) {
    // Dispatch custom event
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('localechange', {
        detail: { locale, isRTL: this.isRTL() }
      }));
    }

    // Notify other parts of extension
    chrome.runtime.sendMessage({
      type: 'LOCALE_CHANGED',
      locale,
      isRTL: this.isRTL()
    });
  }

  // Pluralization support
  getPlural(key, count, substitutions = []) {
    const pluralKey = this.getPluralKey(key, count);
    return this.getMessage(pluralKey, [count, ...substitutions]);
  }

  getPluralKey(key, count) {
    // Simple English pluralization rules
    if (this.currentLocale.startsWith('en')) {
      return count === 1 ? `${key}_one` : `${key}_other`;
    }

    // Add more complex pluralization rules for other languages
    // This is a simplified version - real implementation would use
    // proper pluralization libraries like Intl.PluralRules
    
    return count === 1 ? `${key}_one` : `${key}_other`;
  }

  // Gender support for languages that need it
  getGenderedMessage(key, gender = 'neutral', substitutions = []) {
    const genderedKey = `${key}_${gender}`;
    const message = this.getMessage(genderedKey, substitutions);
    
    // Fallback to neutral if gendered version doesn't exist
    if (message === genderedKey) {
      return this.getMessage(key, substitutions);
    }
    
    return message;
  }
}

// Initialize global i18n instance
const i18n = new InternationalizationManager();

// Global helper functions
window.t = (key, substitutions) => i18n.getMessage(key, substitutions);
window.tPlural = (key, count, substitutions) => i18n.getPlural(key, count, substitutions);
window.formatNumber = (number) => i18n.formatNumber(number);
window.formatCurrency = (amount, currency) => i18n.formatCurrency(amount, currency);
window.formatDate = (date, style) => i18n.formatDate(date, style);
```

#### **Translation Management System**
```javascript
// Translation Management and Validation
class TranslationManager {
  constructor() {
    this.sourceLocale = 'en';
    this.translations = new Map();
    this.validationRules = new Map();
    this.setupValidationRules();
  }

  setupValidationRules() {
    // Length validation
    this.validationRules.set('length', (source, translation, locale) => {
      const sourceLength = source.length;
      const translationLength = translation.length;
      
      // Allow 50% variance in length
      const maxLength = sourceLength * 1.5;
      const minLength = sourceLength * 0.5;
      
      if (translationLength > maxLength || translationLength < minLength) {
        return {
          valid: false,
          message: `Translation length (${translationLength}) is outside acceptable range (${minLength}-${maxLength})`
        };
      }
      
      return { valid: true };
    });

    // Placeholder validation
    this.validationRules.set('placeholders', (source, translation, locale) => {
      const sourcePlaceholders = source.match(/\$\d+/g) || [];
      const translationPlaceholders = translation.match(/\$\d+/g) || [];
      
      if (sourcePlaceholders.length !== translationPlaceholders.length) {
        return {
          valid: false,
          message: `Placeholder count mismatch. Source: ${sourcePlaceholders.length}, Translation: ${translationPlaceholders.length}`
        };
      }
      
      // Check if all placeholders are present
      for (const placeholder of sourcePlaceholders) {
        if (!translationPlaceholders.includes(placeholder)) {
          return {
            valid: false,
            message: `Missing placeholder: ${placeholder}`
          };
        }
      }
      
      return { valid: true };
    });

    // HTML tag validation
    this.validationRules.set('html', (source, translation, locale) => {
      const sourceTags = source.match(/<[^>]+>/g) || [];
      const translationTags = translation.match(/<[^>]+>/g) || [];
      
      if (sourceTags.length !== translationTags.length) {
        return {
          valid: false,
          message: `HTML tag count mismatch. Source: ${sourceTags.length}, Translation: ${translationTags.length}`
        };
      }
      
      return { valid: true };
    });

    // Character encoding validation
    this.validationRules.set('encoding', (source, translation, locale) => {
      // Check for proper Unicode encoding
      try {
        const encoded = encodeURIComponent(translation);
        const decoded = decodeURIComponent(encoded);
        
        if (decoded !== translation) {
          return {
            valid: false,
            message: 'Translation contains invalid Unicode characters'
          };
        }
      } catch (error) {
        return {
          valid: false,
          message: 'Translation encoding validation failed'
        };
      }
      
      return { valid: true };
    });
  }

  async loadTranslations(locale) {
    try {
      const response = await fetch(chrome.runtime.getURL(`_locales/${locale}/messages.json`));
      const translations = await response.json();
      this.translations.set(locale, translations);
      return translations;
    } catch (error) {
      console.error(`Failed to load translations for ${locale}:`, error);
      return {};
    }
  }

  validateTranslation(key, sourceText, translatedText, locale) {
    const results = [];
    
    for (const [ruleName, rule] of this.validationRules) {
      const result = rule(sourceText, translatedText, locale);
      
      if (!result.valid) {
        results.push({
          rule: ruleName,
          key,
          locale,
          message: result.message,
          severity: result.severity || 'warning'
        });
      }
    }
    
    return results;
  }

  async validateAllTranslations(locale) {
    const sourceTranslations = await this.loadTranslations(this.sourceLocale);
    const targetTranslations = await this.loadTranslations(locale);
    
    const validationResults = [];
    
    for (const [key, sourceMessage] of Object.entries(sourceTranslations)) {
      const targetMessage = targetTranslations[key];
      
      if (!targetMessage) {
        validationResults.push({
          rule: 'missing',
          key,
          locale,
          message: 'Translation missing',
          severity: 'error'
        });
        continue;
      }
      
      const sourceText = typeof sourceMessage === 'object' ? sourceMessage.message : sourceMessage;
      const targetText = typeof targetMessage === 'object' ? targetMessage.message : targetMessage;
      
      const results = this.validateTranslation(key, sourceText, targetText, locale);
      validationResults.push(...results);
    }
    
    return validationResults;
  }

  generateTranslationReport(locale) {
    return this.validateAllTranslations(locale).then(results => {
      const report = {
        locale,
        timestamp: new Date().toISOString(),
        summary: {
          total: results.length,
          errors: results.filter(r => r.severity === 'error').length,
          warnings: results.filter(r => r.severity === 'warning').length
        },
        issues: results
      };
      
      return report;
    });
  }

  async exportTranslationsForTranslator(locale) {
    const sourceTranslations = await this.loadTranslations(this.sourceLocale);
    const targetTranslations = await this.loadTranslations(locale);
    
    const exportData = {
      metadata: {
        sourceLocale: this.sourceLocale,
        targetLocale: locale,
        exportDate: new Date().toISOString(),
        totalStrings: Object.keys(sourceTranslations).length
      },
      translations: []
    };
    
    for (const [key, sourceMessage] of Object.entries(sourceTranslations)) {
      const sourceText = typeof sourceMessage === 'object' ? sourceMessage.message : sourceMessage;
      const targetMessage = targetTranslations[key];
      const targetText = targetMessage ? 
        (typeof targetMessage === 'object' ? targetMessage.message : targetMessage) : '';
      
      exportData.translations.push({
        key,
        source: sourceText,
        target: targetText,
        description: typeof sourceMessage === 'object' ? sourceMessage.description : '',
        context: this.getTranslationContext(key),
        status: targetText ? 'translated' : 'pending'
      });
    }
    
    return exportData;
  }

  getTranslationContext(key) {
    // Provide context based on key naming patterns
    if (key.startsWith('error_')) return 'Error message';
    if (key.startsWith('button_')) return 'Button text';
    if (key.startsWith('menu_')) return 'Menu item';
    if (key.startsWith('tooltip_')) return 'Tooltip text';
    if (key.startsWith('title_')) return 'Page/section title';
    if (key.startsWith('description_')) return 'Description text';
    
    return 'General text';
  }
}

// Initialize translation manager
const translationManager = new TranslationManager();
```

#### **Language Switcher Component**
```javascript
// Language Switcher UI Component
class LanguageSwitcher {
  constructor(containerId) {
    this.container = document.getElementById(containerId);
    this.currentLocale = i18n.currentLocale;
    this.availableLanguages = [];
    
    this.initialize();
  }

  async initialize() {
    await this.loadAvailableLanguages();
    this.render();
    this.setupEventListeners();
  }

  async loadAvailableLanguages() {
    try {
      const response = await fetch(chrome.runtime.getURL('_locales/config/languages.json'));
      const config = await response.json();
      this.availableLanguages = Object.entries(config.supported).map(([code, info]) => ({
        code,
        ...info
      }));
    } catch (error) {
      console.error('Failed to load available languages:', error);
      this.availableLanguages = [
        { code: 'en', name: 'English', nativeName: 'English' }
      ];
    }
  }

  render() {
    const currentLang = this.availableLanguages.find(lang => lang.code === this.currentLocale);
    
    this.container.innerHTML = `
      <div class="language-switcher">
        <button class="language-switcher-button" id="languageButton">
          <span class="language-flag">${this.getFlagEmoji(this.currentLocale)}</span>
          <span class="language-name">${currentLang?.nativeName || currentLang?.name || this.currentLocale}</span>
          <span class="language-arrow">‚ñº</span>
        </button>
        <div class="language-dropdown" id="languageDropdown">
          ${this.availableLanguages.map(lang => `
            <div class="language-option ${lang.code === this.currentLocale ? 'active' : ''}" 
                 data-locale="${lang.code}">
              <span class="language-flag">${this.getFlagEmoji(lang.code)}</span>
              <span class="language-name">${lang.nativeName || lang.name}</span>
              ${lang.code === this.currentLocale ? '<span class="checkmark">‚úì</span>' : ''}
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }

  setupEventListeners() {
    const button = this.container.querySelector('#languageButton');
    const dropdown = this.container.querySelector('#languageDropdown');
    const options = this.container.querySelectorAll('.language-option');

    // Toggle dropdown
    button.addEventListener('click', () => {
      dropdown.classList.toggle('open');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (event) => {
      if (!this.container.contains(event.target)) {
        dropdown.classList.remove('open');
      }
    });

    // Handle language selection
    options.forEach(option => {
      option.addEventListener('click', async () => {
        const locale = option.dataset.locale;
        
        if (locale !== this.currentLocale) {
          // Show loading state
          option.classList.add('loading');
          
          try {
            await i18n.setLocale(locale);
            this.currentLocale = locale;
            this.render();
            
            // Notify parent components
            this.onLanguageChange(locale);
          } catch (error) {
            console.error('Failed to change language:', error);
            // Show error message
            this.showError(i18n.t('error_language_change_failed'));
          } finally {
            option.classList.remove('loading');
          }
        }
        
        dropdown.classList.remove('open');
      });
    });

    // Listen for external locale changes
    window.addEventListener('localechange', (event) => {
      this.currentLocale = event.detail.locale;
      this.render();
    });
  }

  getFlagEmoji(locale) {
    const flagMap = {
      'en': 'üá∫üá∏',
      'en-US': 'üá∫üá∏',
      'en-GB': 'üá¨üáß',
      'en-CA': 'üá®üá¶',
      'en-AU': 'üá¶üá∫',
      'es': 'üá™üá∏',
      'es-ES': 'üá™üá∏',
      'es-MX': 'üá≤üáΩ',
      'fr': 'üá´üá∑',
      'de': 'üá©üá™',
      'pt': 'üáµüáπ',
      'pt-BR': 'üáßüá∑',
      'zh': 'üá®üá≥',
      'zh-CN': 'üá®üá≥',
      'zh-TW': 'üáπüáº',
      'ja': 'üáØüáµ',
      'ko': 'üá∞üá∑',
      'ru': 'üá∑üá∫',
      'it': 'üáÆüáπ',
      'nl': 'üá≥ÔøΩÔøΩÔøΩÔøΩ',
      'pl': 'üáµüá±',
      'tr': 'üáπüá∑',
      'ar': 'üá∏üá¶',
      'he': 'üáÆüá±',
      'hi': 'üáÆüá≥',
      'th': 'üáπüá≠',
      'vi': 'üáªüá≥'
    };

    return flagMap[locale] || flagMap[locale.split('-')[0]] || 'üåê';
  }

  onLanguageChange(locale) {
    // Override this method to handle language changes
    console.log(`Language changed to: ${locale}`);
  }

  showError(message) {
    // Simple error display - can be enhanced
    const errorDiv = document.createElement('div');
    errorDiv.className = 'language-error';
    errorDiv.textContent = message;
    this.container.appendChild(errorDiv);
    
    setTimeout(() => {
      errorDiv.remove();
    }, 3000);
  }
}

// CSS for language switcher (to be included in your CSS file)
const languageSwitcherCSS = `
.language-switcher {
  position: relative;
  display: inline-block;
}

.language-switcher-button {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 6px;
  background: white;
  cursor: pointer;
  font-size: 14px;
}

.language-switcher-button:hover {
  background: #f5f5f5;
}

.language-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: white;
  border: 1px solid #ddd;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  max-height: 200px;
  overflow-y: auto;
  z-index: 1000;
  display: none;
}

.language-dropdown.open {
  display: block;
}

.language-option {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 14px;
}

.language-option:hover {
  background: #f5f5f5;
}

.language-option.active {
  background: #e3f2fd;
  font-weight: 500;
}

.language-flag {
  font-size: 16px;
}

.checkmark {
  margin-left: auto;
  color: #2196f3;
  font-weight: bold;
}

.language-error {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: #f44336;
  color: white;
  padding: 8px;
  border-radius: 4px;
  font-size: 12px;
  margin-top: 4px;
}

/* RTL support */
.rtl .language-dropdown {
  left: auto;
  right: 0;
}

.rtl .checkmark {
  margin-left: 0;
  margin-right: auto;
}
`;

// Inject CSS
if (typeof document !== 'undefined') {
  const style = document.createElement('style');
  style.textContent = languageSwitcherCSS;
  document.head.appendChild(style);
}
```

---

## üìã FORMATO DE SA√çDA OBRIGAT√ìRIO

### **OBJETIVO:** Implementar suporte completo a m√∫ltiplos idiomas

### **ESTRUTURA DE ENTREGA:**

```
üì¶ INTERNATIONALIZATION SYSTEM
‚îú‚îÄ‚îÄ üåê _locales/                    # Arquivos de localiza√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ en/                         # Ingl√™s (base)
‚îÇ   ‚îú‚îÄ‚îÄ es/                         # Espanhol
‚îÇ   ‚îú‚îÄ‚îÄ fr/                         # Franc√™s
‚îÇ   ‚îú‚îÄ‚îÄ de/                         # Alem√£o
‚îÇ   ‚îú‚îÄ‚îÄ pt/                         # Portugu√™s
‚îÇ   ‚îú‚îÄ‚îÄ zh/                         # Chin√™s
‚îÇ   ‚îú‚îÄ‚îÄ ja/                         # Japon√™s
‚îÇ   ‚îú‚îÄ‚îÄ ko/                         # Coreano
‚îÇ   ‚îú‚îÄ‚îÄ ru/                         # Russo
‚îÇ   ‚îú‚îÄ‚îÄ ar/                         # √Årabe (RTL)
‚îÇ   ‚îú‚îÄ‚îÄ he/                         # Hebraico (RTL)
‚îÇ   ‚îî‚îÄ‚îÄ config/                     # Configura√ß√µes i18n
‚îú‚îÄ‚îÄ üîß i18n/                        # Sistema de internacionaliza√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ i18n-manager.js             # Gerenciador principal
‚îÇ   ‚îú‚îÄ‚îÄ translation-manager.js      # Gerenciador de tradu√ß√µes
‚îÇ   ‚îú‚îÄ‚îÄ language-detector.js        # Detector de idioma
‚îÇ   ‚îú‚îÄ‚îÄ formatter.js                # Formatadores regionais
‚îÇ   ‚îî‚îÄ‚îÄ validator.js                # Validador de tradu√ß√µes
‚îú‚îÄ‚îÄ üé® components/                  # Componentes i18n
‚îÇ   ‚îú‚îÄ‚îÄ language-switcher.js        # Seletor de idioma
‚îÇ   ‚îú‚îÄ‚îÄ rtl-handler.js              # Handler RTL/LTR
‚îÇ   ‚îú‚îÄ‚îÄ date-picker.js              # Date picker localizado
‚îÇ   ‚îî‚îÄ‚îÄ number-input.js             # Input de n√∫meros localizado
‚îú‚îÄ‚îÄ üõ†Ô∏è tools/                       # Ferramentas de tradu√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ translation-extractor.js    # Extrator de strings
‚îÇ   ‚îú‚îÄ‚îÄ translation-validator.js    # Validador de tradu√ß√µes
‚îÇ   ‚îú‚îÄ‚îÄ pseudo-localizer.js         # Pseudo-localiza√ß√£o para testes
‚îÇ   ‚îî‚îÄ‚îÄ translation-exporter.js     # Exportador para tradutores
‚îú‚îÄ‚îÄ üìä analytics/                   # Analytics de i18n
‚îÇ   ‚îú‚îÄ‚îÄ language-usage.js           # Uso por idioma
‚îÇ   ‚îú‚îÄ‚îÄ translation-coverage.js     # Cobertura de tradu√ß√µes
‚îÇ   ‚îî‚îÄ‚îÄ locale-performance.js       # Performance por locale
‚îú‚îÄ‚îÄ üß™ testing/                     # Testes de i18n
‚îÇ   ‚îú‚îÄ‚îÄ i18n-tests.js               # Testes do sistema i18n
‚îÇ   ‚îú‚îÄ‚îÄ translation-tests.js        # Testes de tradu√ß√µes
‚îÇ   ‚îú‚îÄ‚îÄ rtl-tests.js                # Testes RTL
‚îÇ   ‚îî‚îÄ‚îÄ locale-switching-tests.js   # Testes de troca de idioma
‚îú‚îÄ‚îÄ üìö documentation/               # Documenta√ß√£o i18n
‚îÇ   ‚îú‚îÄ‚îÄ translation-guide.md        # Guia para tradutores
‚îÇ   ‚îú‚îÄ‚îÄ developer-guide.md          # Guia para desenvolvedores
‚îÇ   ‚îú‚îÄ‚îÄ style-guide.md              # Guia de estilo
‚îÇ   ‚îî‚îÄ‚îÄ locale-support.md           # Suporte a locales
‚îî‚îÄ‚îÄ ‚öôÔ∏è config/                      # Configura√ß√µes
    ‚îú‚îÄ‚îÄ supported-languages.json    # Idiomas suportados
    ‚îú‚îÄ‚îÄ translation-workflow.json   # Workflow de tradu√ß√£o
    ‚îî‚îÄ‚îÄ formatting-rules.json       # Regras de formata√ß√£o
```

### **CADA IDIOMA DEVE CONTER:**

#### **üìù Arquivos de Tradu√ß√£o**
- messages.json - Mensagens principais
- ui.json - Textos de interface
- errors.json - Mensagens de erro
- help.json - Textos de ajuda
- store.json - Descri√ß√µes para store

#### **üé® Adapta√ß√µes Culturais**
- Formata√ß√£o de n√∫meros
- Formata√ß√£o de datas
- Formata√ß√£o de moedas
- Dire√ß√£o de texto (RTL/LTR)
- Conven√ß√µes culturais

#### **‚úÖ Valida√ß√£o de Qualidade**
- Completude das tradu√ß√µes
- Consist√™ncia terminol√≥gica
- Valida√ß√£o de placeholders
- Verifica√ß√£o de encoding
- Testes de layout

---

## ‚úÖ CHECKLIST DE INTERNACIONALIZA√á√ÉO COMPLETA

### **üåê Setup B√°sico**
- [ ] **Estrutura de arquivos** _locales configurada
- [ ] **Sistema i18n** implementado e funcional
- [ ] **Detec√ß√£o autom√°tica** de idioma do usu√°rio
- [ ] **Fallback para ingl√™s** configurado
- [ ] **Seletor de idioma** implementado na UI
- [ ] **Persist√™ncia** da escolha do usu√°rio
- [ ] **Notifica√ß√£o** de mudan√ßas de idioma
- [ ] **Recarregamento** autom√°tico da interface

### **üìù Tradu√ß√µes**
- [ ] **Idiomas Tier 1** traduzidos (EN, ES, FR, DE, PT, ZH, JA, KO)
- [ ] **Idiomas Tier 2** traduzidos conforme necess√°rio
- [ ] **Todas as strings** extra√≠das e traduzidas
- [ ] **Pluraliza√ß√£o** implementada onde necess√°rio
- [ ] **G√™nero** suportado para idiomas que precisam
- [ ] **Contexto** fornecido para tradutores
- [ ] **Valida√ß√£o** de tradu√ß√µes implementada
- [ ] **Workflow** de traduÔøΩÔøΩ√£o estabelecido

### **üé® Adapta√ß√µes Visuais**
- [ ] **Suporte RTL** implementado (√°rabe, hebraico)
- [ ] **Layouts responsivos** a diferentes comprimentos de texto
- [ ] **Fontes** apropriadas para cada idioma
- [ ] **Formata√ß√£o** de n√∫meros, datas e moedas
- [ ] **√çcones e imagens** culturalmente apropriados
- [ ] **Cores** culturalmente sens√≠veis
- [ ] **Espa√ßamento** ajustado para diferentes scripts
- [ ] **Quebras de linha** apropriadas

### **üß™ Testing e Qualidade**
- [ ] **Testes automatizados** para i18n
- [ ] **Pseudo-localiza√ß√£o** para detectar problemas
- [ ] **Testes de layout** em todos os idiomas
- [ ] **Testes de performance** com diferentes locales
- [ ] **Valida√ß√£o** de completude das tradu√ß√µes
- [ ] **Testes de troca** de idioma em runtime
- [ ] **Testes cross-browser** para i18n
- [ ] **Testes de acessibilidade** em diferentes idiomas

### **üìä Monitoramento**
- [ ] **Analytics** de uso por idioma
- [ ] **M√©tricas** de performance por locale
- [ ] **Tracking** de problemas de tradu√ß√£o
- [ ] **Feedback** de usu√°rios sobre tradu√ß√µes
- [ ] **Cobertura** de tradu√ß√µes monitorada
- [ ] **Qualidade** das tradu√ß√µes avaliada
- [ ] **Atualiza√ß√µes** de tradu√ß√£o automatizadas
- [ ] **Relat√≥rios** regulares de i18n

---

## üéØ RESULTADO ESPERADO

### **üì¶ Deliverable Final**
Uma **extens√£o completamente internacionalizada** que:

‚úÖ **Suporta m√∫ltiplos idiomas** nativamente  
‚úÖ **Detecta automaticamente** o idioma do usu√°rio  
‚úÖ **Permite troca** de idioma em runtime  
‚úÖ **Adapta layouts** para RTL e diferentes comprimentos  
‚úÖ **Formata dados** apropriadamente por regi√£o  
‚úÖ **Mant√©m qualidade** das tradu√ß√µes  
‚úÖ **Facilita adi√ß√£o** de novos idiomas  

### **üåç Benef√≠cios da Internacionaliza√ß√£o**
- **üìà Expans√£o de 300%** no mercado potencial
- **üë• Melhor experi√™ncia** para usu√°rios globais
- **‚≠ê Ratings mais altos** em diferentes regi√µes
- **üí∞ Maior receita** de mercados internacionais
- **üöÄ Crescimento acelerado** em novos mercados
- **üèÜ Vantagem competitiva** global

**A internacionaliza√ß√£o deve tornar a extens√£o verdadeiramente global, proporcionando uma experi√™ncia nativa e culturalmente apropriada para usu√°rios de diferentes idiomas e regi√µes.**